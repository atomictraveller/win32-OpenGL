
/*
			//gl_Position = viewMatrix * vec4(pos.x, pos.y, pos.z, 1.0);
			//gl_Position = rotationMatrix * viewMatrix * projectionMatrix * vec4(pos.x, pos.y, pos.z, 1.0);
		#version 330 core
		in vec3 FragPos;      // Fragment position in world space
		in vec3 Normal;       // Surface normal in world space
		in vec2 TexCoords;    // Texture coordinates
		uniform sampler2D texture1;    // Texture sampler
		out vec4 FragColor;		// Output to framebuffer
		void main() {
			// Calculate lighting
			vec3 lightPos = vec3(1.0, 1.0, 1.0);   // Example light position
			vec3 lightColor = vec3(1.0, 1.0, 1.0); // Example light color
			vec3 ambientColor = vec3(0.1, 0.1, 0.1); // Example ambient color
			vec3 norm = normalize(Normal);
			vec3 lightDir = normalize(lightPos - FragPos);
			float diff = max(dot(norm, lightDir), 0.0);
			vec3 diffuse = diff * lightColor;
			// Texture mapping
			vec4 texColor = texture(texture1, TexCoords);
			// Combine lighting and texture
			vec3 result = (ambientColor + diffuse) * texColor.rgb;
			FragColor = vec4(result, texColor.a);
		}
*/



void makeheightfield() {

	float grid[256][256];	//	y,x
	float normx[256][256];
	float normy[256][256];
	float perlin[16][16];
	for (int j = 0; j < 16; j++) for (int i = 0; i < 16; i++) {
		rnd = 196314165 * rnd + 907633515;
		perlin[j][i] = (float)rnd * 2.3283e-10f;
		//perlin[j][i] *= perlin[j][i] * (3.f - perlin[j][i] - perlin[j][i]);
	}


	//for (int j = 0; j < 256; j++) for (int i = 0; i < 256; i++) grid[j][i] = sin((i * .07f + j * (j - i) * .00047f) * .5f) * cos(i * j * .00053f) * 4.f - 15.f;
	
	for (int j = 0; j < 256; j++) for (int i = 0; i < 256; i++) {
		float scale = .009f;
		float gain = .8f;
		int octaves = 7;
		float hfsum = 0.f;
		for (int c = 0; c < octaves; c++) {
			float px = (float)i * scale;
			float py = (float)j * scale;
			unsigned char x0, y0, x1, y1;
			x0 = (unsigned char)px;	y0 = (unsigned char)py;
			x1 = (x0 + 1) & 255;	y1 = (y0 + 1) & 255;
			float dx = px - (float)x0;
			float dy = py - (float)y0;
			x0 &= 15;	y0 &= 15;	x1 &= 15;	y1 &= 15;
			dx *= dx * (3.f - dx - dx);	dy *= dy * (3.f - dy - dy);
			float i0 = perlin[x0][y0] + dx * (perlin[x1][y0] - perlin[x0][y0]);
			float i1 = perlin[x0][y1] + dx * (perlin[x1][y1] - perlin[x0][y1]);
			i0 += dy * (i1 - i0);
			i0 = 1.f - abs(1.f - 2.f * i0);
			hfsum += i0 * gain;
			gain *= .65f;
			scale *= 1.75f;
		}
		grid[j][i] = hfsum * 10.f - 20.f;
	}
	for (int j = 0; j < 256; j++) {
		normx[j][0] = grid[j][0] - grid[j][1];	//	calculate normals
		normy[0][j] = grid[0][j] - grid[1][j];
		for (int i = 1; i < 255; i++) {
			normx[j][i] = ((grid[j][i - 1] - grid[j][i]) + (grid[j][i] - grid[j][i + 1])) * 0.5f;
			normy[i][j] = ((grid[i - 1][j] - grid[i][j]) + (grid[i][j] - grid[i + 1][j])) * 0.5f;
		}
		normx[j][255] = grid[j][254] - grid[j][255];
		normy[255][j] = grid[254][j] - grid[255][j];
	}
	for (int j = 0; j < 256; j++) for (int i = 0; i < 256; i++) {
		float hyp = 1.f / sqrt(normx[j][i] * normx[j][i] + normy[j][i] * normy[j][i] + 1.f);
		normx[j][i] *= hyp;	normy[j][i] *= hyp;
	}
	//1 3 5..
	//0 2 4  two to begin, +1 per tri
	for (int j = 0; j < 255; j++) {
		int jx = j * 3060;	int jm = j + 1;
		for (int i = 0; i < 510; i += 2) {
			register int ix = jx + i * 6;	int tx = i >> 1;
			vertices[ix] = tx - 127;	vertices[ix + 1] = grid[j][tx];	vertices[ix + 2] = j - 127;
			vertices[ix + 3] = vertices[ix + 4] = vertices[ix + 5] = .5f;
			vertices[ix + 6] = tx - 127;	vertices[ix + 7] = grid[jm][tx];	vertices[ix + 8] = j - 126;
			vertices[ix + 9] = vertices[ix + 10] = vertices[ix + 11] = .5f;
		}
	}
	for (int k = 0; k < 255; k++) {
		unsigned long int tj = k * 510;
		for (int i = 0; i < 510; i += 2) {
			unsigned long int j = tj + i;
			indices[j] = j;		indices[j + 1] = j + 1;
		}
	}

}




	for (int j = 0; j < 255; j++) {
		int jx = j * 4590;	int jm = j + 1;//3060
		for (int i = 0; i < 510; i += 2) {
			register int ix = jx + i * 9;	int tx = i >> 1;
			vertices[ix] = tx - 127;	vertices[ix + 1] = grid[j][tx];	vertices[ix + 2] = j - 127;
			vertices[ix + 3] = vertices[ix + 4] = vertices[ix + 5] = .5f;
			//vertices[ix + 6] = normx[j][tx];	vertices[ix + 7] = normz[j][tx];	vertices[ix + 8] = normy[j][tx];

			vertices[ix + 6] = tx - 127;	vertices[ix + 7] = grid[jm][tx];	vertices[ix + 8] = j - 126;
			vertices[ix + 9] = vertices[ix + 10] = vertices[ix + 11] = .5f;
			//vertices[ix + 15] = normx[jm][tx];	vertices[ix + 16] = normz[jm][tx];	vertices[ix + 17] = normy[jm][tx];
		}
	}




	//for (int j = 0; j < 256; j++) for (int i = 0; i < 256; i++) grid[j][i] = sin((i * .07f + j * (j - i) * .00047f) * .5f) * cos(i * j * .00053f) * 4.f - 15.f;
	
	for (int j = 0; j < 256; j++) for (int i = 0; i < 256; i++) {
		float scale = .009f;
		float gain = .8f;
		int octaves = 7;
		float hfsum = 0.f;
		for (int c = 0; c < octaves; c++) {
			float px = (float)i * scale;
			float py = (float)j * scale;
			unsigned char x0, y0, x1, y1;
			x0 = (unsigned char)px;	y0 = (unsigned char)py;
			x1 = (x0 + 1) & 255;	y1 = (y0 + 1) & 255;
			float dx = px - (float)x0;
			float dy = py - (float)y0;
			x0 &= 15;	y0 &= 15;	x1 &= 15;	y1 &= 15;
			dx *= dx * (3.f - dx - dx);	dy *= dy * (3.f - dy - dy);
			float i0 = perlin[x0][y0] + dx * (perlin[x1][y0] - perlin[x0][y0]);
			float i1 = perlin[x0][y1] + dx * (perlin[x1][y1] - perlin[x0][y1]);
			i0 += dy * (i1 - i0);
			i0 = 1.f - abs(1.f - 2.f * i0);
			hfsum += i0 * gain;
			gain *= .65f;
			scale *= 1.75f;
		}
		grid[j][i] = hfsum * 10.f - 20.f;
	}
	for (int j = 0; j < 256; j++) {
		normx[j][0] = grid[j][0] - grid[j][1];	//	calculate normals
		normy[0][j] = grid[0][j] - grid[1][j];
		for (int i = 1; i < 255; i++) {
			normx[j][i] = ((grid[j][i - 1] - grid[j][i]) + (grid[j][i] - grid[j][i + 1])) * 0.5f;
			normy[i][j] = ((grid[i - 1][j] - grid[i][j]) + (grid[i][j] - grid[i + 1][j])) * 0.5f;
		}
		normx[j][255] = grid[j][254] - grid[j][255];
		normy[255][j] = grid[254][j] - grid[255][j];
	}
	for (int j = 0; j < 256; j++) for (int i = 0; i < 256; i++) {
		float hyp = 1.f / sqrt(normx[j][i] * normx[j][i] + normy[j][i] * normy[j][i] + 1.f);
		normx[j][i] *= hyp;	normy[j][i] *= hyp;	normz[j][i] = hyp;
	}



	//  |  1  0       0       0 |//xaxis
	//M | 0  cos(A) -sin(A)  0 |
	//	|  0  sin(A)  cos(A)  0 |
	//	|  0  0       0       1 |

		//cx, 0.f, sx, 0.f,	//	just y axis rotation
		//0.f, 1.f / aspect, 0.f, 0.f,
		//-sx, 0.f, cx, 0.f,

	// |cos(A) -sin(A)   0   0 |//zaxis
	//	| sin(A)   cos(A)   0   0 |
	//	|  0        0        1   0 |
	//	|  0        0        0   1 |


	float eye[] = { 0.f, .5f, 1.f };
	float look[] = { 0.f, .5f, .0f };	//	look at point

	float view[16] = { 0 };

	view[15] = 1.f;
	view[4] = 0.f;	//	up unit vector x,y,z
	view[5] = 1.f;
	view[6] = 0.f;
	view[8] = eye[0] - look[0];
	view[9] = eye[1] - look[1];
	view[10] = eye[2] - look[2];
	float tno = view[8] * view[8] + view[9] * view[9] + view[10] * view[10];
	if (tno > 0.f) tno = 1.f / sqrt(tno);
	view[8] *= tno;	view[9] *= tno;	view[10] *= tno;

	view[0] = view[5] * view[10] - view[6] * view[9];//cross
	view[1] = view[6] * view[8] - view[4] * view[10];
	view[2] = view[4] * view[9] - view[5] * view[8];
	tno = view[0] * view[0] + view[1] * view[1] + view[2] * view[2];
	if (tno > 0.f) tno = 1.f / sqrt(tno);
	view[0] *= tno;	view[1] *= tno;	view[2] *= tno;
	view[3] = view[0] * eye[0] + view[1] * eye[1] + view[2] * eye[2];	//dots
	view[7] = view[4] * eye[4] + view[5] * eye[5] + view[6] * eye[6];
	view[11] = view[8] * eye[8] + view[9] * eye[9] + view[10] * eye[10];
	view[3] = -view[3];	view[7] = -view[7];	view[11] = -view[11];